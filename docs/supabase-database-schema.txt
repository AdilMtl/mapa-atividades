# üóÑÔ∏è Schema Completo do Banco de Dados Supabase

## üìã Vis√£o Geral

O sistema utiliza **Supabase (PostgreSQL)** com 3 schemas principais:
- `auth.*` - Tabelas de autentica√ß√£o (gerenciadas pelo Supabase)
- `public.*` - Tabelas da aplica√ß√£o
- Triggers e fun√ß√µes autom√°ticas

**√öltima atualiza√ß√£o:** 29/09/2025 (v3.3.1)

---

## üîê Schema: auth.* (Supabase Auth)

### Tabela: `auth.users`
Gerenciada automaticamente pelo Supabase Auth.

**Colunas principais:**
```sql
id                  UUID PRIMARY KEY
email               VARCHAR UNIQUE
encrypted_password  VARCHAR
email_confirmed_at  TIMESTAMP
created_at          TIMESTAMP
last_sign_in_at     TIMESTAMP
N√£o modificar diretamente! Usar sempre supabase.auth.* APIs.

üë• Schema: public.* (Aplica√ß√£o)
1. Tabela: usuarios
Prop√≥sito: Dados principais do usu√°rio (sincronizado com auth.users)
sqlCREATE TABLE public.usuarios (
  id UUID PRIMARY KEY,
  email TEXT NOT NULL,
  nome TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
Rela√ß√µes:

id deve corresponder a um registro em auth.users.id
Populado automaticamente via trigger handle_new_user()

RLS Policies:
sql-- Permitir INSERT de qualquer fonte (para trigger funcionar)
CREATE POLICY "usuarios_insert" ON usuarios
FOR INSERT WITH CHECK (true);

-- Usu√°rios s√≥ veem seus pr√≥prios dados
CREATE POLICY "usuarios_select" ON usuarios
FOR SELECT USING (auth.uid() = id);

-- Usu√°rios s√≥ atualizam seus pr√≥prios dados
CREATE POLICY "usuarios_update" ON usuarios
FOR UPDATE USING (auth.uid() = id);

-- Usu√°rios s√≥ deletam seus pr√≥prios dados
CREATE POLICY "usuarios_delete" ON usuarios
FOR DELETE USING (auth.uid() = id);

2. Tabela: profiles
Prop√≥sito: Perfil completo do usu√°rio (nome, emoji, prefer√™ncias)
sqlCREATE TABLE public.profiles (
  id UUID PRIMARY KEY,
  full_name VARCHAR,
  emoji VARCHAR,
  created_at TIMESTAMP WITHOUT TIME ZONE,
  updated_at TIMESTAMP WITHOUT TIME ZONE,
  email_notifications BOOLEAN DEFAULT true,
  
  -- Foreign key para auth.users
  CONSTRAINT profiles_id_fkey 
    FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE
);
Rela√ß√µes:

id ‚Üí auth.users.id (FK com CASCADE)
Populado automaticamente via trigger handle_new_user()

RLS Policies:
sql-- Permitir INSERT de qualquer fonte (para trigger funcionar)
CREATE POLICY "profiles_insert" ON profiles
FOR INSERT WITH CHECK (true);

-- Usu√°rios s√≥ veem seu pr√≥prio perfil
CREATE POLICY "profiles_select" ON profiles
FOR SELECT USING (auth.uid() = id);

-- Usu√°rios s√≥ atualizam seu pr√≥prio perfil
CREATE POLICY "profiles_update" ON profiles
FOR UPDATE USING (auth.uid() = id);

-- Usu√°rios s√≥ deletam seu pr√≥prio perfil
CREATE POLICY "profiles_delete" ON profiles
FOR DELETE USING (auth.uid() = id);

3. Tabela: atividades
Prop√≥sito: Atividades mapeadas na matriz Impacto √ó Clareza
sqlCREATE TABLE public.atividades (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  nome TEXT NOT NULL,
  eixo_x INTEGER NOT NULL, -- Clareza (0-10)
  eixo_y INTEGER NOT NULL, -- Impacto (0-10)
  horas_mes INTEGER,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  
  CONSTRAINT atividades_user_id_fkey 
    FOREIGN KEY (user_id) REFERENCES usuarios(id) ON DELETE CASCADE
);
RLS Policies:
sql-- Usu√°rios s√≥ veem suas pr√≥prias atividades
CREATE POLICY "atividades_select" ON atividades
FOR SELECT USING (auth.uid() = user_id);

-- Usu√°rios s√≥ inserem atividades para si
CREATE POLICY "atividades_insert" ON atividades
FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Usu√°rios s√≥ atualizam suas atividades
CREATE POLICY "atividades_update" ON atividades
FOR UPDATE USING (auth.uid() = user_id);

-- Usu√°rios s√≥ deletam suas atividades
CREATE POLICY "atividades_delete" ON atividades
FOR DELETE USING (auth.uid() = user_id);

4. Tabela: authorized_emails
Prop√≥sito: Lista de emails autorizados a criar conta (assinantes)
sqlCREATE TABLE public.authorized_emails (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  expires_at DATE NOT NULL,
  notes TEXT,
  stripe_customer_id TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_authorized_emails_email ON authorized_emails(email);
CREATE INDEX idx_authorized_emails_expires ON authorized_emails(expires_at);
RLS Policies:
sql-- Apenas service_role pode acessar
CREATE POLICY "authorized_emails_admin_only" ON authorized_emails
FOR ALL TO service_role USING (true);
Uso: Verificada pela API /api/auth/check-authorization

5. Tabelas do Pr√©-Diagn√≥stico
roi_prediag_sessions
sqlCREATE TABLE roi_prediag_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  completed_at TIMESTAMP WITH TIME ZONE,
  profile VARCHAR(50) NOT NULL,
  agenda VARCHAR(50) NOT NULL,
  pain VARCHAR(100) NOT NULL,
  top_activity VARCHAR(100) NOT NULL,
  goal VARCHAR(100) NOT NULL,
  mix_essencial INTEGER NOT NULL,
  mix_estrategico INTEGER NOT NULL,
  mix_tatico INTEGER NOT NULL,
  mix_distracao INTEGER NOT NULL,
  insight_hash VARCHAR(100),
  ip_address INET,
  user_agent TEXT,
  duration_seconds INTEGER
);
RLS: Acesso an√¥nimo permitido (API p√∫blica)
roi_leads
sqlCREATE TABLE roi_leads (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(100),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  source VARCHAR(50) DEFAULT 'prediagnostico',
  last_session_id UUID REFERENCES roi_prediag_sessions(id)
);
RLS: Apenas service_role
roi_events
sqlCREATE TABLE roi_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  session_id UUID REFERENCES roi_prediag_sessions(id),
  event_name VARCHAR(100) NOT NULL,
  page_url VARCHAR(500),
  payload JSONB,
  ip_address INET,
  user_agent TEXT
);
RLS: Acesso an√¥nimo para INSERT

‚öôÔ∏è Fun√ß√µes e Triggers
1. Trigger: Sincroniza√ß√£o Autom√°tica de Usu√°rios
Prop√≥sito: Quando um usu√°rio √© criado em auth.users, automaticamente criar registros em usuarios e profiles
Fun√ß√£o: handle_new_user()
sqlCREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
BEGIN
  -- Inserir em usuarios
  INSERT INTO public.usuarios (id, email, nome, created_at)
  VALUES (NEW.id, NEW.email, 'Usu√°rio', NOW())
  ON CONFLICT (id) DO NOTHING;
  
  -- Inserir em profiles
  INSERT INTO public.profiles (id, full_name, created_at, updated_at, email_notifications)
  VALUES (NEW.id, 'Usu√°rio', NOW(), NOW(), true)
  ON CONFLICT (id) DO NOTHING;
  
  RETURN NEW;
END;
$function$;
Caracter√≠sticas:

SECURITY DEFINER: Executa com permiss√µes do criador (postgres)
SET search_path TO 'public': Garante acesso correto √†s tabelas
ON CONFLICT DO NOTHING: Evita erros se registro j√° existir
N√£o tem EXCEPTION: Erros v√£o falhar explicitamente (melhor para debug)

Trigger: on_auth_user_created
sqlCREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();
Quando dispara: Imediatamente ap√≥s criar usu√°rio em auth.users
Testado e verificado: ‚úÖ Funcionando em 29/09/2025

2. Trigger: Auto-update de timestamps
Fun√ß√£o: update_updated_at_column()
sqlCREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';
Triggers que usam:
sql-- Para roi_leads
CREATE TRIGGER update_roi_leads_updated_at 
  BEFORE UPDATE ON roi_leads 
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Adicionar para outras tabelas conforme necess√°rio

üîç Queries de Diagn√≥stico
Verificar sincroniza√ß√£o de usu√°rios
sql-- Ver status completo de todos os usu√°rios
SELECT 
  au.email,
  au.email_confirmed_at,
  au.created_at as auth_created,
  u.nome as usuarios_nome,
  p.full_name as profiles_nome,
  CASE 
    WHEN u.id IS NULL THEN '‚ùå FALTA usuarios'
    WHEN p.id IS NULL THEN '‚ùå FALTA profiles'
    ELSE '‚úÖ COMPLETO'
  END as status
FROM auth.users au
LEFT JOIN usuarios u ON au.id = u.id
LEFT JOIN profiles p ON au.id = p.id
ORDER BY au.created_at DESC
LIMIT 20;
Verificar RLS ativo
sqlSELECT 
  schemaname,
  tablename,
  rowsecurity as rls_enabled
FROM pg_tables 
WHERE schemaname = 'public'
  AND tablename IN ('usuarios', 'profiles', 'atividades', 'authorized_emails')
ORDER BY tablename;
Verificar triggers ativos
sqlSELECT 
  trigger_name,
  event_object_table,
  action_timing,
  event_manipulation
FROM information_schema.triggers
WHERE trigger_schema = 'public'
  OR (trigger_schema = 'auth' AND event_object_table = 'users')
ORDER BY event_object_table, trigger_name;
Verificar fun√ß√µes
sqlSELECT 
  routine_name,
  routine_type,
  security_type
FROM information_schema.routines
WHERE routine_schema = 'public'
  AND routine_name IN ('handle_new_user', 'update_updated_at_column')
ORDER BY routine_name;

üõ†Ô∏è Scripts de Manuten√ß√£o
Corrigir usu√°rios sem sincroniza√ß√£o
sql-- Identificar usu√°rios problem√°ticos
SELECT 
  au.id,
  au.email,
  au.email_confirmed_at
FROM auth.users au
LEFT JOIN usuarios u ON au.id = u.id
WHERE au.email_confirmed_at IS NOT NULL
  AND u.id IS NULL;

-- Corrigir manualmente (se necess√°rio)
INSERT INTO usuarios (id, email, nome, created_at)
SELECT 
  au.id,
  au.email,
  'Usu√°rio',
  NOW()
FROM auth.users au
LEFT JOIN usuarios u ON au.id = u.id
WHERE au.email_confirmed_at IS NOT NULL
  AND u.id IS NULL;

INSERT INTO profiles (id, full_name, created_at, updated_at, email_notifications)
SELECT 
  au.id,
  'Usu√°rio',
  NOW(),
  NOW(),
  true
FROM auth.users au
LEFT JOIN profiles p ON au.id = p.id
WHERE au.email_confirmed_at IS NOT NULL
  AND p.id IS NULL;

üìä √çndices para Performance
sql-- Usuarios
CREATE INDEX IF NOT EXISTS idx_usuarios_email ON usuarios(email);
CREATE INDEX IF NOT EXISTS idx_usuarios_created ON usuarios(created_at DESC);

-- Profiles
CREATE INDEX IF NOT EXISTS idx_profiles_created ON profiles(created_at DESC);

-- Atividades
CREATE INDEX IF NOT EXISTS idx_atividades_user ON atividades(user_id);
CREATE INDEX IF NOT EXISTS idx_atividades_created ON atividades(created_at DESC);

-- Authorized emails
CREATE INDEX IF NOT EXISTS idx_authorized_emails_email ON authorized_emails(email);
CREATE INDEX IF NOT EXISTS idx_authorized_emails_expires ON authorized_emails(expires_at);

‚ö†Ô∏è Avisos Importantes
1. Modifica√ß√µes Manuais

NUNCA modificar diretamente auth.users
NUNCA deletar registros de usuarios sem deletar em auth.users primeiro
Sempre usar APIs do Supabase para autentica√ß√£o

2. RLS Security

Todas as tabelas public.* DEVEM ter RLS ativo
Policies devem usar auth.uid() para identificar usu√°rio
Service role ignora RLS (usar com cuidado)

3. Triggers

handle_new_user() √© cr√≠tico para funcionamento do sistema
Se modificar, testar extensivamente
Sempre usar ON CONFLICT DO NOTHING para seguran√ßa

4. Foreign Keys

profiles.id ‚Üí auth.users.id: Se deletar user, profile √© deletado (CASCADE)
atividades.user_id ‚Üí usuarios.id: Se deletar usu√°rio, atividades s√£o deletadas

## üîß Fun√ß√µes Administrativas

### public.admin_list_users()
**Prop√≥sito:** Listar usu√°rios de `auth.users` evitando bug do `auth.admin.listUsers()`
```sql
CREATE OR REPLACE FUNCTION public.admin_list_users()
RETURNS TABLE (
  id uuid,
  email varchar(255),
  created_at timestamptz,
  last_sign_in_at timestamptz,
  email_confirmed_at timestamptz
) 
SECURITY DEFINER
SET search_path = auth, public
AS $$
BEGIN
  RETURN QUERY SELECT u.id, u.email, u.created_at, u.last_sign_in_at, u.email_confirmed_at FROM auth.users u;
END;
$$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION public.admin_list_users() TO service_role;
```

**Usado em:** `/api/admin/assinantes` para listar usu√°rios com contas


üîó Refer√™ncias

Documenta√ß√£o Supabase Auth: https://supabase.com/docs/guides/auth
PostgreSQL Triggers: https://www.postgresql.org/docs/current/sql-createtrigger.html
RLS Policies: https://supabase.com/docs/guides/auth/row-level-security